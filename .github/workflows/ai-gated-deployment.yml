name: AI-Gated Deployment

on:
  push:
    branches:
      - main
      - master
  pull_request:
    branches:
      - main
      - master

concurrency:
  group: deployment-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  # STEP 1: Static Analysis (Fast checks)
  static-analysis:
    runs-on: ubuntu-latest
    outputs:
      has_issues: ${{ steps.check.outputs.has_issues }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Install Dependencies
        working-directory: ./agent-python
        run: pip install -r requirements.txt
      
      - name: Run Quality Checks
        id: check
        working-directory: ./agent-python
        run: |
          python quality_checks.py > quality-report.txt 2>&1 || echo "has_issues=true" >> $GITHUB_OUTPUT
          cat quality-report.txt
        env:
          DEPLOYMENT_URL: "file://${{ github.workspace }}/index.html"
        continue-on-error: true
      
      - name: Upload Quality Report
        uses: actions/upload-artifact@v4
        with:
          name: quality-report
          path: agent-python/quality-report.txt
          retention-days: 30
  
  # STEP 2: AI Analysis (Deep reasoning)
  ai-analysis:
    runs-on: ubuntu-latest
    needs: static-analysis
    outputs:
      analysis_status: ${{ steps.ai-check.outputs.status }}
      has_critical_issues: ${{ steps.ai-check.outputs.has_critical }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Install Dependencies
        working-directory: ./agent-python
        run: pip install -r requirements.txt
      
      - name: Deploy to Staging for Analysis
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./
          publish_branch: gh-pages-staging
          exclude_assets: 'agent/**,agent-python/**,node_modules/**,.github/**'
      
      - name: Wait for Staging Deployment
        run: sleep 30
      
      - name: Run AI Analysis
        id: ai-check
        working-directory: ./agent-python
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          DEPLOYMENT_URL: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/
        run: |
          # Run AI analysis
          python ai_reasoning_checks.py > ai-analysis.txt 2>&1 || true
          
          # Check for critical issues
          if grep -qi "CRITICAL\|HIGH" ai-analysis.txt; then
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "has_critical=true" >> $GITHUB_OUTPUT
            echo "‚ùå AI Analysis found critical issues"
          else
            echo "status=passed" >> $GITHUB_OUTPUT
            echo "has_critical=false" >> $GITHUB_OUTPUT
            echo "‚úÖ AI Analysis passed"
          fi
          
          cat ai-analysis.txt
        continue-on-error: true
      
      - name: Upload AI Analysis Report
        uses: actions/upload-artifact@v4
        with:
          name: ai-analysis-report
          path: agent-python/ai-analysis-report.json
          retention-days: 30
      
      - name: Create Analysis Summary
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let analysis = 'Analysis report not available';
            try {
              const report = JSON.parse(fs.readFileSync('agent-python/ai-analysis-report.json', 'utf8'));
              
              // Format UX issues
              const uxIssues = report.ux_analysis?.ai_insights || [];
              const criticalCount = uxIssues.filter(i => i.severity === 'CRITICAL' || i.severity === 'HIGH').length;
              
              analysis = '## ü§ñ AI Deployment Analysis\n\n';
              analysis += '**Status:** ' + (criticalCount > 0 ? '‚ùå BLOCKED' : '‚úÖ PASSED') + '\n';
              analysis += '**Critical/High Issues:** ' + criticalCount + '\n\n';
              
              if (criticalCount > 0) {
                analysis += '### üö® Issues Found:\n\n';
                uxIssues.forEach(issue => {
                  if (issue.severity === 'CRITICAL' || issue.severity === 'HIGH') {
                    analysis += '#### ' + issue.type + ' (' + issue.severity + ')\n';
                    analysis += '**Issue:** ' + (issue.issue || issue.message || 'See details') + '\n';
                    if (issue.fix) {
                      analysis += '**Fix:** ' + issue.fix + '\n';
                    }
                    analysis += '\n';
                  }
                });
                
                analysis += '\n### ‚ö†Ô∏è Deployment Blocked\n\n';
                analysis += 'This deployment has been blocked due to critical UX/accessibility issues.\n\n';
                analysis += '**Options:**\n';
                analysis += '1. Fix the issues and push again\n';
                analysis += '2. Override with manual approval (use workflow_dispatch with override flag)\n\n';
              }
              
              analysis += '<details>\n<summary>üìã Full AI Analysis</summary>\n\n```json\n';
              analysis += JSON.stringify(report, null, 2).substring(0, 5000);
              analysis += '\n```\n</details>';
              
            } catch (e) {
              analysis += '\nError reading report: ' + e.message;
            }
            
            // Post as comment on PR or commit
            if (context.payload.pull_request) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: analysis
              });
            } else {
              await github.rest.repos.createCommitComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                commit_sha: context.sha,
                body: analysis
              });
            }
            
            // Set job summary
            await core.summary
              .addRaw(analysis)
              .write();
  
  # STEP 3: Create Issue for Approval (if issues found)
  create-approval-issue:
    runs-on: ubuntu-latest
    needs: ai-analysis
    if: needs.ai-analysis.outputs.has_critical_issues == 'true'
    outputs:
      issue_number: ${{ steps.create-issue.outputs.issue_number }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      
      - name: Download AI Analysis Report
        uses: actions/download-artifact@v4
        with:
          name: ai-analysis-report
          path: agent-python/
      
      - name: Create Approval Issue
        id: create-issue
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let issueBody = '## üö® Deployment Blocked by AI Analysis\n\n';
            issueBody += '**Commit:** ${{ github.sha }}\n';
            issueBody += '**Branch:** ${{ github.ref_name }}\n';
            issueBody += '**Author:** @${{ github.actor }}\n';
            issueBody += '**Time:** ' + new Date().toISOString() + '\n\n';
            issueBody += '---\n\n';
            
            try {
              const report = JSON.parse(fs.readFileSync('agent-python/ai-analysis-report.json', 'utf8'));
              const uxIssues = report.ux_analysis?.ai_insights || [];
              const criticalIssues = uxIssues.filter(i => i.severity === 'CRITICAL' || i.severity === 'HIGH');
              
              issueBody += '### üîç Issues Found (' + criticalIssues.length + ')\n\n';
              
              criticalIssues.forEach((issue, index) => {
                issueBody += '#### ' + (index + 1) + '. ' + issue.type + ' (' + issue.severity + ')\n\n';
                issueBody += '**Problem:** ' + (issue.issue || issue.message || 'See details') + '\n\n';
                if (issue.fix) {
                  issueBody += '**Suggested Fix:** ' + issue.fix + '\n\n';
                }
                if (issue.user_impact) {
                  issueBody += '**User Impact:** ' + issue.user_impact + '\n\n';
                }
                issueBody += '---\n\n';
              });
            } catch (e) {
              issueBody += '**Error loading detailed report:** ' + e.message + '\n\n';
            }
            
            issueBody += '## üéØ What Should You Do?\n\n';
            issueBody += '### Option 1: Fix the Issues (Recommended)\n\n';
            issueBody += '1. Review the issues above\n';
            issueBody += '2. Fix them in your code\n';
            issueBody += '3. Commit and push\n';
            issueBody += '4. This issue will be closed automatically\n\n';
            issueBody += '### Option 2: Override and Deploy Anyway\n\n';
            issueBody += '‚ö†Ô∏è **Use this only if:**\n';
            issueBody += '- The AI analysis is incorrect (false positive)\n';
            issueBody += '- You have a valid reason to proceed\n';
            issueBody += '- This is a time-critical hotfix\n\n';
            issueBody += '**To override:**\n';
            issueBody += '1. Review the issues carefully\n';
            issueBody += '2. Comment on this issue with: `approve: [your reason]`\n';
            issueBody += '3. Example: `approve: False positive - buttons are in different sections with clear context`\n';
            issueBody += '4. Deployment will proceed automatically\n\n';
            issueBody += '---\n\n';
            issueBody += '**Commit SHA:** `${{ github.sha }}`\n';
            issueBody += '**Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}';
            
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'üö® Deployment Blocked: AI Analysis Failed for ' + '${{ github.sha }}'.substring(0, 7),
              body: issueBody,
              labels: ['deployment-blocked', 'ai-analysis', 'needs-review']
            });
            
            core.setOutput('issue_number', issue.data.number);
            
            // Also post comment on commit
            await github.rest.repos.createCommitComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha,
              body: 'üö® **Deployment Blocked**\n\nAI analysis found critical issues. See issue #' + issue.data.number + ' for details and approval options.'
            });
            
            return issue.data.number;
  
  # STEP 4: Wait for Approval
  wait-for-approval:
    runs-on: ubuntu-latest
    needs: create-approval-issue
    outputs:
      approved: ${{ steps.check-approval.outputs.approved }}
      approval_reason: ${{ steps.check-approval.outputs.reason }}
    steps:
      - name: Wait and Check for Approval
        id: check-approval
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = ${{ needs.create-approval-issue.outputs.issue_number }};
            const maxWaitMinutes = 60; // Wait up to 1 hour
            const checkIntervalSeconds = 30;
            const maxChecks = (maxWaitMinutes * 60) / checkIntervalSeconds;
            
            console.log('Waiting for approval on issue #' + issueNumber);
            console.log('Will check every ' + checkIntervalSeconds + ' seconds for up to ' + maxWaitMinutes + ' minutes');
            
            for (let i = 0; i < maxChecks; i++) {
              // Get all comments on the issue
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber
              });
              
              // Check if any comment contains "approve:"
              for (const comment of comments.data) {
                const body = comment.body.toLowerCase();
                if (body.includes('approve:')) {
                  // Extract reason after "approve:"
                  const match = comment.body.match(/approve:\s*(.+)/i);
                  const reason = match ? match[1].trim() : 'No reason provided';
                  
                  console.log('‚úÖ Approval found!');
                  console.log('Approved by: @' + comment.user.login);
                  console.log('Reason: ' + reason);
                  
                  core.setOutput('approved', 'true');
                  core.setOutput('reason', reason);
                  core.setOutput('approved_by', comment.user.login);
                  
                  // Close the issue
                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    state: 'closed',
                    labels: ['deployment-blocked', 'ai-analysis', 'approved-override']
                  });
                  
                  // Add comment confirming approval
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    body: '‚úÖ **Deployment Approved**\n\nApproved by: @' + comment.user.login + '\nReason: ' + reason + '\n\nProceeding with deployment...'
                  });
                  
                  return true;
                }
              }
              
              // Wait before next check
              if (i < maxChecks - 1) {
                console.log('Check ' + (i + 1) + '/' + maxChecks + ': No approval yet, waiting...');
                await new Promise(resolve => setTimeout(resolve, checkIntervalSeconds * 1000));
              }
            }
            
            // Timeout reached
            console.log('‚ùå Timeout: No approval received within ' + maxWaitMinutes + ' minutes');
            core.setOutput('approved', 'false');
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: '‚è±Ô∏è **Approval Timeout**\n\nNo approval received within ' + maxWaitMinutes + ' minutes. Deployment cancelled.\n\nTo deploy, either:\n1. Fix the issues and push again\n2. Comment `approve: [reason]` and re-run the workflow'
            });
            
            return false;
  
  # STEP 5: Deploy to Production (only if passed or approved)
  deploy-production:
    runs-on: ubuntu-latest
    needs: [ai-analysis, wait-for-approval]
    if: |
      always() && 
      (needs.ai-analysis.outputs.has_critical_issues == 'false' || 
       needs.wait-for-approval.outputs.approved == 'true')
    environment:
      name: production
      url: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      
      - name: Deploy to Production
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./
          publish_branch: gh-pages
          exclude_assets: 'agent/**,agent-python/**,node_modules/**,.github/**'
      
      - name: Deployment Success
        uses: actions/github-script@v7
        with:
          script: |
            const wasOverridden = needs.wait-for-approval.outputs.approved === 'true';
            const emoji = wasOverridden ? '‚ö†Ô∏è' : '‚úÖ';
            const status = wasOverridden ? 'Deployed with override' : 'Deployed successfully';
            
            let body = '## ' + emoji + ' Production Deployment\n\n' +
              '**Status:** ' + status + '\n' +
              '**URL:** https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/\n' +
              '**Commit:** ${{ github.sha }}\n' +
              '**Deployed by:** @${{ github.actor }}\n\n';
            
            if (wasOverridden) {
              const reason = '${{ needs.wait-for-approval.outputs.approval_reason }}';
              body += '‚ö†Ô∏è **Note:** AI analysis was overridden for this deployment.\n';
              body += '**Override Reason:** ' + reason + '\n';
            } else {
              body += '‚úÖ All AI checks passed.\n';
            }
            
            await github.rest.repos.createCommitComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha,
              body: body
            });
